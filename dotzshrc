# -*- mode: sh; coding: utf-8 -*-

[ -f /etc/zsh/zshrc ] && source /etc/zsh/zshrc

############################################################
##  外部設定ファイル

source_if_exist(){
    [ -f "$1" ] || return
    echo load $1
    source "$1"
}

## mintty の ANSI Colors の設定
source_if_exist "$HOME/.zshrc.d/color_schemes/my_colors"

## rvm
source_if_exist "/usr/local/rvm/scripts/rvm"
source_if_exist "$HOME/.rvm/scripts/rvm"

############################################################
# env
EDITOR='vi'

############################################################
# パスの設定
## 重複したパスを登録しない。
typeset -U path
## (N-/): 存在しないディレクトリは登録しない。
##    パス(...): ...という条件にマッチするパスのみ残す。
##            N: NULL_GLOBオプションを設定。
##               globがマッチしなかったり存在しないパスを無視する。
##            -: シンボリックリンク先のパスを評価。
##            /: ディレクトリのみ残す。
path=($HOME/{.rvm,.rbenv,local}/bin(N-/)
        /usr{/local,/local/rvm,/usr,}/bin(N-/)
        /app/{script,mingw/tdm/bin,gs/bin,gs/lib}(N-/)
        /usr/local/rvm/bin(N-/)
        $GEM_HOME/bin(N-/)
        $path)

# sudo時のパスの設定
## -x: export SUDO_PATHも一緒に行う。
## -T: SUDO_PATHとsudo_pathを連動する。
typeset -xT SUDO_PATH sudo_path
typeset -U sudo_path
sudo_path=({,/usr/pkg,/usr/local,/usr}/sbin(N-/)
        $sudo_path $path)

if [ $TERM = "xterm" ] && infocmp xterm-256color > /dev/null 2>&1
then
    export TERM="xterm-256color"
fi

# 表示言語設定
export LANG=ja_JP.UTF-8

# 補完スクリプトのパス
fpath=({$HOME/.rvm,/usr/local/rvm}/scripts/zsh/Completion(N-/)
    $HOME/.zshrc.d/completion(N-/)
    $fpath)

_cake (){
    if [ -f Cakefile ]
    then
        compadd `cake | grep '^cake ' | sed -e "s/cake \([^ ]*\) .*/\1/" | grep -v '^$'`
    fi
}

############################################################
## alias, funcction の設定
if which screen > /dev/null 2>&1
then
    alias s="screen"
    [ $STY ] && alias s="screen -X focus; screen"
fi

if ls --color > /dev/null 2>&1
then
    alias ls="ls -F --color"
elif ls --G > /dev/null 2>&1
then
    alias ls="ls -F -G"
fi

function md(){
    cat <<EOF
<html><head>
<meta charset="UTF-8" />
<style>
  h1,h2,h3,h4,h5,h6 {font-family: "Hiragino Kaku Gothic Pro W3", "ヒラギノ角ゴ Pro W3", Meiryo,
"メイリオ", "MS P Gothic", "ＭＳ Ｐゴシック", sans-serif}
  p, li {font-family:Georgia, Times, "Times New Roman", serif}
</style>
</head><body>
EOF
    markdown "$1"
    echo '</body></html>'
}

function markdown_preview(){
    if [ $# -ne 1 ]; then
        echo "error: invalid arguments"
        echo "usage: $0 markdown_file"
        return 1;
    fi

    if [ ! -f "$1" ]; then
        echo "error: $1 dose not exists"
        return 1;
    fi

    md "$1" | w3m -T text/html -dump

    # 縦割りしたときにズレる問題解決
    if [ $STY ]
    then
        sleep 0.2
        screen -X redisplay
    fi
}

function j(){
    class=`echo $1 | sed -e "s/\\.java$//"`
    shift
    echo $@
    if [ -f build.xml ]; then
        ant && java -DDebug=on $class $@
    else
        javac $class.java && java -DDebug=on $do_java $@
    fi
}

## refe の文字コードをUTF-8に修正
function refe(){
    refe "$@" | nkf -Ew
}

## ぐぐる
function g(){
    w3m "google.com/search?q=$@"
}

## emacs server の設定
EMACS_SERVER_NAME="$USER"
[ $STY ] && EMACS_SERVER_NAME="$EMACS_SERVER_NAME-$STY"
export EMACS_SERVER_NAME

alias emacsclient="emacsclient -n -s $EMACS_SERVER_NAME"

function e(){
    emacsclient "$@" || emacsserver "$@"
}

function view(){
    [ -f "$1" ] || (echo "ファイルが見つかりませんでした: $file"; exit 1)
    emacsclient -e "(find-file-read-only \"$1\")"
}
alias r=v
alias v=view

function emacsserver(){
    if ! emacsclient -s "$EMACS_SERVER_NAME" -e "server-name" > /dev/null 2>&1
    then
        screen emacs -nw --eval "(let () (setq server-name \"$EMACS_SERVER_NAME\") (server-start) (setq confirm-kill-emacs 'yes-or-no-p))" "$@"
    else
        echo "already started (server name: $EMACS_SERVER_NAME)" >&2
    fi
}

# 横長画面向きレイアウト
function widescreen(){
    local columns=160
    if ! [ $STY ]
    then
        echo 'run `screen`'
        return
    elif [ $COLUMNS -lt $columns ]
    then
        echo "less than $columns columns"
        return
    fi

    screen -X layout new
    screen -X split -v

    if ! emacsclient -s "$EMACS_SERVER_NAME" -e "server-name" > /dev/null 2>&1
    then
        screen emacs --eval "(let () (setq server-name \"$EMACS_SERVER_NAME\") (server-start) (setq confirm-kill-emacs 'yes-or-no-p))"
    fi

    screen -X next
    screen -X focus
    screen -X select 1
    screen -X focus
}

# 色一覧
function color_list(){
    for c in {016..255}
    do
        echo -n "\e[38;5;${c}m $c"
        [ $(($((c-16))%6)) -eq 5 ] && echo
    done
}

# open
if [ -f /usr/bin/xdg-open ]
then
    alias open=/usr/bin/xdg-open
    alias o=/usr/bin/xdg-open
fi

## 256色生成用便利関数
### red: 0-5
### green: 0-5
### blue: 0-5
color256()
{
    echo -n $(($1 * 36 + $2 * 6 + $3 + 16))
}

color256_echo(){
    if [ $# -lt 3 ]
    then
        echo "usage: $0 RED GREEN BLUE [string...]"
        echo "  RED, GREEN, BLUE: 0-5"
        echo "sample: $0 0 5 5 foo"
        return 1
    fi

    local r=$1; shift
    local g=$1; shift
    local b=$1; shift

    echo "\e[38;5;`color256 $r $g $b`m$@"
}

#####################################################################
# バージョンシステム管理下のディレクトリにいる時の諸々の設定
autoload -Uz vcs_info
zstyle ':vcs_info:*' get-revision true
zstyle ':vcs_info:*' check-for-changes true
zstyle ':vcs_info:*' max-exports 6
zstyle ':vcs_info:*' formats '%s' '%b' '%i' '%c' '%u'
zstyle ':vcs_info:*' actionformats '%s' '%b' '%i' '%c' '%u' '%a'

# インデックスに追加された場合に表示される文字列
# zstyle ':vcs_info:git:*' stagedstr "S"
# 作業コピーに変更があった場合に表示される文字列
# zstyle ':vcs_info:git:*' unstagedstr "U"

# bzr のとき、vcs_info でネットワーク使わせない
zstyle ':vcs_info:bzr:*' use-simple true

update_rprompt(){
    LANG=en_US.UTF-8 vcs_info
    export VCS_NAME=$vcs_info_msg_0_
    export VCS_BRANCH_NAME=$vcs_info_msg_1_
    export VCS_REVISION=$vcs_info_msg_2_
    export VCS_ACTION=$vcs_info_msg_5_
    export VCS_IS_COMMITED=t
    export VCS_IS_ADDED=t
    if [ $VCS_NAME ]
    then
        [ -n "$vcs_info_msg_3_" -a ! $vcs_info_msg_3_ = %c ]&&export VCS_IS_COMMITED=
        [ -n "$vcs_info_msg_4_" -a ! $vcs_info_msg_4_ = %u ]&&export VCS_IS_ADDED=
    fi
    # echo $vcs_info_msg_3_$vcs_info_msg_4_$VCS_IS_COMMITED$VCS_IS_ADDED
}
precmd_functions=($precmd_functions update_rprompt)

#########################################################################
##    プロンプト を生成
colors=(
    # $'\e[0;30m' # black
    $'\e[0;31m' # red
    $'\e[0;32m' # green
    $'\e[0;33m' # brown
    $'\e[0;34m' # blue
    $'\e[0;35m' # purple
    $'\e[0;36m' # cyan
    # $'\e[0;37m' # gray

    # light colors
    # $'\e[1;30m' # black
    $'\e[1;31m' # red
    $'\e[1;32m' # green
    $'\e[1;33m' # brown
    $'\e[1;34m' # blue
    $'\e[1;35m' # purple
    $'\e[1;36m' # cyan
    # $'\e[1;37m' # gray
)

if [ `echotc Co` = "256" ]
then
    colors=()
    local c=0
    for c in {000..255}
    do
        # 無視する色
        if [ $c -eq 000 ] || [ $c -ge 016 -a $c -le 027 ] ||\
           [ $c -ge 052 -a $c -le 066 ] || [ $c -ge 088 -a $c -le 098 ] ||\
           [ $c -ge 232 -a $c -le 244 ]
        then
            continue
        fi
        colors=($colors $'\e[38;5;'$c'm')
    done
fi

export USER_COLOR=$colors[$((`echo "$USER" | sum | cut -f1 -d' '`%${#colors}))+1]
export HOST_COLOR=$colors[$((`echo "$HOST" | sum | cut -f1 -d' '`%${#colors}))+1]
export BAR_COLOR=$'\e[0;37m'
export TIME_COLOR=$'\e[0;37m'
if [ `echotc Co` = "256" ]
then
    export BAR_COLOR=$'\e[38;5;240m'
    export TIME_COLOR=$'\e[38;5;245m'
fi

construct_left(){
    local non_color=
    while getopts n opt
    do
        case $opt in
            n) local no_color=true;;
        esac
    done
    shift `expr $OPTIND - 1`
    local current_path=$1

    local u= h= p= v= d=
    if [ ! $no_color ]
    then
        local u=$USER_COLOR h=$HOST_COLOR p='%F{yellow}' d='%f'
        local v=$(
            if [ "$vcs_info_msg_3_" = %c ]
            then echo -n '%f'
            elif [ $VCS_IS_ADDED ] && [ $VCS_IS_COMMITED ]
            then echo -n '%F{green}'
            else echo -n '%F{red}'
            fi
        )
    fi

    # プロンプトのフォーマット
    echo -n "$u${USER}$d@$h${HOST}$d:$p${current_path}"
    [ $VCS_NAME ] && echo -n " $v($VCS_NAME/$VCS_BRANCH_NAME)"
    [ $VCS_ACTION ] && echo -n "[$VCS_ACTION]"
    echo -n "$d"
}

update_prompt(){
    local datetime="`date +'%Y/%m/%d %H:%M:%S'`"
    local escaped_home="`echo ${HOME}|sed -e 's/\//\\\\\//g'`"
    local current_path="`pwd|sed -e \"s/^${escaped_home}/~/\"`"

    # local left="$USER@$HOST:$current_path"
    local left="$(construct_left -n $current_path)"
    local right=" ${datetime} "
    local num_bar=$((${COLUMNS}-${#left}-${#right}))

    if [ $num_bar -lt 0 ]
    then
        local datetime="`date +'%H:%M:%S'`"
        local right=" ${datetime} "
        local num_bar=$((${COLUMNS}-${#left}-${#right}))
    fi

    if [ $num_bar -lt 0 ]
    then
        local right=''
        local num_bar=$((${COLUMNS}-${#left}-${#right}))
    fi

    local sep='-'
    local bar=''
    local i=0
    while [ $num_bar -gt $((${#bar}+${#sep})) ]
    do
        local bar="$sep$bar"
        local i=$((i+1))
        # [ 0 -eq $((i%10)) ] && local bar="-$bar"
    done
    while [ $num_bar -gt ${#bar} ]
    do
        local bar=" $bar"
    done

    local bar="$BAR_COLOR$bar"
    local right="$TIME_COLOR$right"
    # local left="${USER_COLOR}${USER}%f@${HOST_COLOR}${HOST}%f:%F{yellow}${current_path}%f"
    local left="$(construct_left $current_path)"
    PROMPT=$'\n'"${left}${bar}${right}"$'\n'"%f%(!.#.$) "
}
precmd_functions=($precmd_functions update_prompt)
PROMPT="${USER_COLOR}${USER}%f@${HOST_COLOR}${HOST}%f %F{yellow}%~%f "$'\n'"%(!.#.$) "

############################################################
##  screen の window タイトルを設定
update_screen_title() {
    local shell=`echo -n ${SHELL} | sed -e 's/^.*\///'`
    local dir=`print -P '%~' | xargs basename`
    echo -n "\033k${shell}#${dir}\033\\" 2>/dev/null
}
[ "$STY" ] && precmd_functions=($precmd_functions update_screen_title)

############################################################
##  windows で動いてる時は、job 一覧表示だけする
display_jobs(){ echo; jobs; }
[ "$OS" = "Windows_NT" ] && precmd_functions=(display_jobs)

############################################################
##  zsh プロパティ

HISTFILE=$HOME/.zsh-history
HISTSIZE=100000
SAVEHIST=100000

## 補完機能の強化
autoload -U compinit
compinit -u
compdef _cake cake

## コアダンプサイズを制限
limit coredumpsize 102400

## 出力の文字列末尾に改行コードが無い場合でも表示
unsetopt promptcr

## 色を使う
setopt prompt_subst

## ビープを鳴らさない
setopt nobeep

## 内部コマンド jobs の出力をデフォルトで jobs -l にする
setopt long_list_jobs

## 補完候補一覧でファイルの種別をマーク表示
setopt list_types

## サスペンド中のプロセスと同じコマンド名を実行した場合はリジューム
setopt auto_resume

## 補完候補を一覧表示
setopt auto_list

## 直前と同じコマンドをヒストリに追加しない
setopt hist_ignore_dups

## cd 時に自動で push
setopt autopushd

## 同じディレクトリを pushd しない
setopt pushd_ignore_dups

## ファイル名で #, ~, ^ の 3 文字を正規表現として扱う
setopt extended_glob

## TAB で順に補完候補を切り替える
setopt auto_menu

## zsh の開始, 終了時刻をヒストリファイルに書き込む
setopt extended_history

## =command を command のパス名に展開する
setopt equals

## --prefix=/usr などの = 以降も補完
setopt magic_equal_subst

## ヒストリを呼び出してから実行する間に一旦編集
setopt hist_verify

# ファイル名の展開で辞書順ではなく数値的にソート
setopt numeric_glob_sort

## 出力時8ビットを通す
setopt print_eight_bit

## ヒストリを共有
setopt share_history

## 補完候補のカーソル選択を有効に
zstyle ':completion:*:default' menu select=1

## 補完候補の色づけ
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}

## ディレクトリ名だけで cd
setopt auto_cd

## カッコの対応などを自動的に補完
setopt auto_param_keys

## ディレクトリ名の補完で末尾の / を自動的に付加し、次の補完に備える
setopt auto_param_slash

## スペルチェック
setopt correct

## sudo時にはsudo用のパスも使う。
zstyle ':completion:sudo:*' environ PATH="$SUDO_PATH:$PATH"

## 特定のコマンドの補完を無効化
# compdef -d java

## マシンごとの設定
! [ -f ~/.zshrc.local ] && touch ~/.zshrc.local
source ~/.zshrc.local

## rbenv
if which rbenv > /dev/null 2>&1 &&
    ! which rvm > /dev/null 2>&1
then
    echo "load rbenv"
    eval "$(rbenv init -)"
fi
